ðŸ”§ Dynamic Programming (DP) Basics
- Definition: A method for solving problems by breaking them down into overlapping subproblems and reusing previously computed solutions.
- Comparison to other paradigms:
  - *Greedy*: Makes the locally optimal choice at each step.
  - *Divide and Conquer*: Splits into independent subproblems (no overlap).
  - *DP*: Solves overlapping subproblems and combines results (with reuse).



âœ… Three Steps to Apply DP
1. Define the recurrence â€” establish a recursive relation.
2. Identify the subproblem space â€” parameters should be bounded by a low-degree polynomial to ensure tractability.
3. Choose an evaluation order â€” ensure subproblems are computed before they're needed (e.g., top-down with memoization or bottom-up iteration).



ðŸ’¡ Memoization vs. Iteration
- Memoization: Top-down recursion with caching. Simple to write, easier to get right.
- Iteration: Bottom-up approach using loops. Often more space/time efficient and avoids call stack overhead.
- Tip: Start with memoization to validate correctness, then optimize with iteration if needed.



ðŸ“˜ Example 1: Fibonacci Numbers
- Recurrence: `F(n) = F(n-1) + F(n-2)`
- Naive recursion: Exponential time.
- Memoized: O(n) time, O(n) space.
- Space-optimized: O(n) time, O(1) space (only store last two values).



ðŸ“¦ Example 2: Weighted Interval Scheduling
- Input: List of jobs with start time, end time, and weight/value.
- Goal: Maximize total weight of non-overlapping jobs.
- Steps:
  - Sort jobs by end time.
  - Precompute `p(j)` = index of the last job before job `j` that doesnâ€™t overlap.
  - Recurrence: `OPT(j) = max(v_j + OPT(p(j)), OPT(j-1))`
- Approaches:
  - Recursive: exponential.
  - Memoized: O(n log n) (if `p(j)` is binary searched).
  - Iterative: same complexity, faster in practice.
- Recovery: Track choices to reconstruct optimal job subset.



ðŸ“ˆ Example 3: Longest Increasing Subsequence (LIS)
- Input: Array of numbers.
- Goal: Find longest strictly increasing subsequence.
- Recurrence: `OPT[j] = max(1 + OPT[i])` for all `i < j` and `A[i] < A[j]`
- Time: O(nÂ²) with classic DP, O(n log n) with binary search.
- Recovery: Store predecessors to reconstruct the sequence.



ðŸŽ’ Example 4: 0/1 Knapsack
- Input: Items with weight `wáµ¢`, value `váµ¢`, and total capacity `W`.
- Goal: Maximize total value without exceeding capacity.
- Recurrence:
  - If `wáµ¢ â‰¤ w`: `OPT(i, w) = max(OPT(i-1, w), váµ¢ + OPT(i-1, w - wáµ¢))`
  - Else: `OPT(i, w) = OPT(i-1, w)`
- Time/Space: O(nW), pseudo-polynomial (depends on numerical value of `W`, not its bit-length).



ðŸ“Š Summary

| Problem                     | Time   | Space  | Access Pattern                    |
------------------------------------------------------------------------------------|
| Fibonacci                   | O(n)   | O(1)   | Immediate previous values         |
| Weighted Interval Scheduling| O(n)   | O(n)   | Arbitrary previous values (via p) |
| Longest Increasing Subseq.  | O(nÂ²)  | O(n)   | All previous values               |
| 0/1 Knapsack                | O(nW)  | O(nW)  | 2D DP table                       |