ğŸ’ Knapsack Problem (Dynamic Programming)

ğŸ” Problem Definition
- Given 'n' items with:
  - weight 'wi > 0'
  - value 'vi > 0'
- Knapsack capacity = 'W'
- Goal: Choose a subset of items such that:
  - Total weight â‰¤ 'W'
  - Total value is maximized



âŒ Why Greedy Fails
- Greedy (choosing item with best 'vi/wi' ratio) doesn't guarantee optimal.
- Counterexample: Greedy might choose items '{5,2,1}' for value = 35, but the optimal subset '{3,4}' gives value = 40.



ğŸ§  Dynamic Programming Approach

ğŸš« False Start:
- Let 'OPT(i)' = best value using items 1 to 'i'
- Problem: we canâ€™t decide whether item 'i' fits without knowing remaining capacity â†’ missing information

âœ… Correct State Definition:
- Let 'OPT(i, w)' = best value using first 'i' items and weight limit 'w'

ğŸ” Recurrence:
'''plaintext
If wi > w:
    OPT(i, w) = OPT(i-1, w)  // item i doesn't fit
Else:
    OPT(i, w) = max(OPT(i-1, w), vi + OPT(i-1, w - wi))
'''

ğŸ§® Table Construction:
- Bottom-up table: size 'n x W'
- Initialize 'OPT(0, w) = 0' for all 'w' (no items = 0 value)
- Iterate through all 'i = 1 to n' and 'w = 0 to W'



ğŸ§¾ Finding the Optimal Set
- Once the table is filled:
  - Backtrack from 'OPT(n, W)' to reconstruct which items were chosen
  - If 'OPT(i, w) â‰  OPT(i-1, w)', then item 'i' was included



â± Runtime Analysis
- Time Complexity: 'O(nW)' â†’ pseudo-polynomial
- Why â€œpseudoâ€?
  - Input size is proportional to log(W) (binary encoding), but runtime is proportional to 'W'
  - So, technically exponential in the input size



ğŸ“ Bellman-Ford Algorithm (Shortest Paths with Negative Weights)

ğŸ” Problem Definition
- Directed weighted graph 'G = (V, E)', source vertex 's'
- Edge weights 'c(u,v)' can be negative
- Goal: Find shortest paths from 's' to all other vertices



âŒ Why Not Dijkstra?
- Dijkstraâ€™s algorithm fails with negative weights because it assumes once a node is visited with the shortest path, it's final â€” which isnâ€™t true when negative weights can cause future improvements.



âœ… DP Formulation
- Let 'OPT(v, i)' = length of shortest path from 's' to 'v' using at most 'i' edges

ğŸ§¾ Initialization:
'''plaintext
For all v:
    OPT[v, 0] = âˆ
OPT[s, 0] = 0
'''

ğŸ” Recurrence:
'''plaintext
For i = 1 to n-1:
    For each v in V:
        OPT[v, i] = OPT[v, i-1]
        For each edge (u,v):
            OPT[v, i] = min(OPT[v, i], OPT[u, i-1] + c(u,v))
'''

- After 'n-1' iterations, 'OPT[v, n-1]' is the shortest path (since no path has more than 'n-1' edges without a cycle)



âš ï¸ Detecting Negative Cycles
- After 'n-1' iterations, run for up to '2n' iterations
- If any 'OPT[v, 2n] â‰  OPT[v, n-1]', a negative-weight cycle exists



ğŸ§  Path Reconstruction
- Keep a 'pred[v]' array to track where each shortest path came from (which 'u' gave the best path to 'v')
- Use it to reconstruct full paths after the table is complete



â± Runtime Analysis
- Time: 'O(nm)' (where 'm' = number of edges)
- Space: 'O(nÂ²)' (2D array for 'OPT[v, i]')